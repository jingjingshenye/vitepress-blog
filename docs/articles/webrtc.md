# webrtc

- WebRTCï¼ˆWeb Real-Time Communicationï¼‰ï¼Œä¸€ä¸ªå¯ä»¥è®©ç”¨æˆ·ç”¨è‡ªå·±æµé‡ å®žçŽ°éŸ³è§†é¢‘å®žæ—¶é€šä¿¡çš„æ¡†æž¶ï¼ˆAPIsï¼‰ï¼Œæ”¯æŒæµè§ˆå™¨ï¼ˆFirefoxã€Chromeã€safariï¼‰ä»¥åŠ iOSã€Android åŽŸç”Ÿç³»ç»Ÿã€‚

- getUserMedia: èŽ·å–éº¦å…‹é£Žå’Œæ‘„åƒå¤´çš„è®¸å¯ï¼Œä½¿å¾— WebRTC å¯ä»¥æ‹¿åˆ°æœ¬åœ°åª’ä½“æµï¼›
- RTCPeerConnection: å»ºç«‹ç‚¹å¯¹ç‚¹è¿žæŽ¥çš„å…³é”®ï¼Œæä¾›äº†åˆ›å»ºï¼Œä¿æŒï¼Œç›‘æŽ§ï¼Œå…³é—­è¿žæŽ¥çš„æ–¹æ³•çš„å®žçŽ°ã€‚åƒåª’ä½“åå•†ã€æ”¶é›†å€™é€‰åœ°å€éƒ½éœ€è¦å®ƒæ¥å®Œæˆï¼›
- RTCDataChannel: æ”¯æŒç‚¹å¯¹ç‚¹æ•°æ®ä¼ è¾“ï¼Œå¯ç”¨äºŽä¼ è¾“æ–‡ä»¶ã€æ–‡æœ¬æ¶ˆæ¯ç­‰ã€‚

## éŸ³è§†é¢‘å¼•æ“Ž

æœ‰äº† WebRTCï¼Œæˆ‘ä»¬å¯ä»¥å¾ˆæ–¹ä¾¿çš„å®žçŽ°éŸ³è§†é¢‘é€šä¿¡ï¼›è€Œå¦‚æžœæ²¡æœ‰ WebRTC çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬æƒ³è¦å®žçŽ°éŸ³è§†é¢‘é€šä¿¡ï¼Œå°±éœ€è¦åŽ»äº†è§£éŸ³è§†é¢‘ç¼–ç å™¨ç›¸å…³æŠ€æœ¯ã€‚

WebRTC å†…ç½®äº†å¼ºå¤§çš„éŸ³è§†é¢‘å¼•æ“Žï¼Œå¯ä»¥å¯¹åª’ä½“æµè¿›è¡Œç¼–è§£ç ã€å›žå£°æ¶ˆé™¤ã€é™å™ªã€é˜²æ­¢è§†é¢‘æŠ–åŠ¨ç­‰å¤„ç†ï¼Œæˆ‘ä»¬ä½¿ç”¨è€…å¤§å¯ä¸ç”¨åŽ»å…³å¿ƒå¦‚ä½•å®žçŽ° ã€‚ä¸»è¦ä½¿ç”¨çš„éŸ³è§†é¢‘ç¼–è§£ç å™¨æœ‰:

- OPUS: ä¸€ä¸ªå¼€æºçš„ä½Žå»¶è¿ŸéŸ³é¢‘ç¼–è§£ç å™¨ï¼ŒWebRTC é»˜è®¤ä½¿ç”¨ï¼›
- G711: å›½é™…ç”µä¿¡è”ç›Ÿ ITU-T å®šåˆ¶å‡ºæ¥çš„ä¸€å¥—è¯­éŸ³åŽ‹ç¼©æ ‡å‡†ï¼Œæ˜¯ä¸»æµçš„æ³¢å½¢å£°éŸ³ç¼–è§£ç å™¨ï¼›
- VP8: VP8ï¼ŒVP9ï¼Œéƒ½æ˜¯ Google å¼€æºçš„è§†é¢‘ç¼–è§£ç å™¨ï¼ŒçŽ°åœ¨ä¸»è¦ç”¨äºŽ WebRTC è§†é¢‘ç¼–ç ï¼›
- H264: è§†é¢‘ç¼–ç é¢†åŸŸçš„é€šç”¨æ ‡å‡†ï¼Œæä¾›äº†é«˜æ•ˆçš„è§†é¢‘åŽ‹ç¼©ç¼–ç ï¼Œä¹‹å‰ WebRTC æœ€å…ˆæ”¯æŒçš„æ˜¯è‡ªå·±å®¶çš„ VP8ï¼ŒåŽé¢ä¹Ÿæ”¯æŒäº† H264ã€H265 ç­‰ã€‚

è¿˜æœ‰åƒå›žå£°æ¶ˆé™¤`AEC(Acoustic Echo Chancellor)`ã€èƒŒæ™¯å™ªéŸ³æŠ‘åˆ¶`ANS(Automatic Noise Suppression)`å’Œ`Jitter buffer`ç”¨æ¥é˜²æ­¢è§†é¢‘æŠ–åŠ¨ï¼Œè¿™äº›é—®é¢˜åœ¨ WebRTC ä¸­ä¹Ÿæä¾›äº†éžå¸¸æˆç†Ÿã€ç¨³å®šçš„ç®—æ³•ï¼Œå¹¶ä¸”æä¾›å›¾åƒå¢žåŠ å¤„ç†ï¼Œä¾‹å¦‚ç¾Žé¢œï¼Œè´´å›¾ï¼Œæ»¤é•œå¤„ç†ç­‰ã€‚

## ç½‘ç»œ IO

WebRTC ä¼ è¾“å±‚ç”¨çš„æ˜¯ UDP åè®®ï¼Œå› ä¸ºéŸ³è§†é¢‘ä¼ è¾“å¯¹åŠæ—¶æ€§è¦æ±‚æ›´é«˜ï¼Œå¦‚æžœä½¿ç”¨ TCP å½“ä¼ è¾“å±‚åè®®çš„è¯ï¼Œå¦‚æžœå‘ç”Ÿä¸¢åŒ…çš„æƒ…å†µä¸‹ï¼Œå› ä¸º TCP çš„å¯é æ€§ï¼Œå°±ä¼šå°è¯•é‡è¿žï¼Œå¦‚æžœç¬¬ä¸ƒæ¬¡ä¹‹åŽä»ç„¶è¶…æ—¶ï¼Œåˆ™æ–­å¼€ TCP è¿žæŽ¥ã€‚è€Œå¦‚æžœç¬¬ä¸ƒæ¬¡æ”¶åˆ°æ¶ˆæ¯ï¼Œé‚£ä¹ˆä¼ è¾“çš„å»¶è¿Ÿå°±ä¼šè¾¾åˆ° 2 åˆ†é’Ÿã€‚åœ¨å»¶è¿Ÿé«˜çš„æƒ…å†µä¸‹ï¼Œæƒ³åšåˆ°æ­£å¸¸çš„å®žæ—¶é€šè®¯æ˜¾ç„¶æ˜¯ä¸å¯èƒ½çš„ï¼Œæ­¤æ—¶ TCP çš„å¯é æ€§åè€Œæˆäº†å¼Šç«¯ã€‚
è€Œ UDP åˆ™æ­£å¥½ç›¸åï¼Œå®ƒåªè´Ÿè´£æœ‰æ¶ˆæ¯å°±ä¼ è¾“ï¼Œä¸ç®¡æœ‰æ²¡æœ‰æ”¶åˆ°ï¼Œè¿™é‡Œä»Žåº•å±‚æ¥çœ‹æ˜¯æ»¡è¶³ WebRTC çš„éœ€æ±‚çš„ï¼Œæ‰€ä»¥ WebRTC æ˜¯é‡‡ç”¨ UDP æ¥å½“å®ƒçš„ä¼ è¾“å±‚åè®®çš„ã€‚

è¿™é‡Œä¸»è¦ç”¨åˆ°ä»¥ä¸‹å‡ ç§åè®®/æŠ€æœ¯ï¼š

- RTP/SRTP: ä¼ è¾“éŸ³è§†é¢‘æ•°æ®æµæ—¶ï¼Œæˆ‘ä»¬å¹¶ä¸ç›´æŽ¥å°†éŸ³è§†é¢‘æ•°æ®æµäº¤ç»™ UDP ä¼ è¾“ï¼Œè€Œæ˜¯å…ˆç»™éŸ³è§†é¢‘æ•°æ®åŠ ä¸ª RTP å¤´ï¼Œç„¶åŽå†äº¤ç»™ UDP è¿›è¡Œï¼Œä½†æ˜¯ç”±äºŽæµè§ˆå™¨å¯¹å®‰å…¨æ€§è¦æ±‚æ¯”è¾ƒé«˜ï¼Œå¢žåŠ äº†åŠ å¯†è¿™å—çš„å¤„ç†ï¼Œé‡‡ç”¨ SRTP åè®®ï¼›
- RTCPï¼šé€šè¿‡ RTCP å¯ä»¥çŸ¥é“å„ç«¯çš„ç½‘ç»œè´¨é‡ï¼Œè¿™æ ·å¯¹æ–¹å°±å¯ä»¥åšæµæŽ§å¤„ç†ï¼›
- P2P(ICE + STUN + TURN): è¿™æ˜¯ WebRTC æœ€æ ¸å¿ƒçš„æŠ€æœ¯ï¼Œåˆ©ç”¨ ICEã€STUNã€TURN ç­‰æŠ€æœ¯ï¼Œå®žçŽ°äº†æµè§ˆå™¨ä¹‹é—´çš„ç›´æŽ¥ç‚¹å¯¹ç‚¹è¿žæŽ¥ï¼Œè§£å†³äº† NAT ç©¿é€é—®é¢˜ï¼Œå®žçŽ°äº†é«˜è´¨é‡çš„ç½‘ç»œä¼ è¾“ã€‚

é™¤äº†ä»¥ä¸Šä¸‰éƒ¨åˆ†ï¼ŒWebRTC è¿˜éœ€è¦ä¸€ä¸ªä¿¡ä»¤æœåŠ¡åšä¼šè¯ç®¡ç†ï¼Œä½† WebRTC è§„èŒƒé‡Œæ²¡æœ‰åŒ…å«ä¿¡ä»¤åè®®ï¼Œéœ€è¦è‡ªè¡Œå®žçŽ°ã€‚

## é€šä¿¡è¿‡ç¨‹

åŸºäºŽä»¥ä¸Šï¼Œæˆ‘ä»¬æ¥æ€è€ƒä¸‹ WebRTC å®žçŽ°ä¸€å¯¹ä¸€é€šä¿¡éœ€è¦å“ªäº›åŸºæœ¬æ¡ä»¶ï¼Ÿ

- WebRTC ç»ˆç«¯ï¼ˆä¸¤ä¸ªï¼‰ï¼šæœ¬åœ°å’Œè¿œç«¯ï¼Œè´Ÿè´£éŸ³è§†é¢‘é‡‡é›†ã€ç¼–è§£ç ã€NAT ç©¿è¶Šä»¥åŠéŸ³è§†é¢‘æ•°æ®ä¼ è¾“ç­‰ï¼›
- Signal ä¿¡ä»¤æœåŠ¡å™¨ï¼šè‡ªè¡Œå®žçŽ°çš„ä¿¡ä»¤æœåŠ¡ï¼Œè´Ÿè´£ä¿¡ä»¤å¤„ç†ï¼Œå¦‚åŠ å…¥æˆ¿é—´ã€ç¦»å¼€æˆ¿é—´ã€åª’ä½“åå•†æ¶ˆæ¯çš„ä¼ é€’ç­‰ï¼›
- STUN/TURN æœåŠ¡å™¨ï¼šè´Ÿè´£èŽ·å– WebRTC ç»ˆç«¯åœ¨å…¬ç½‘çš„ IP åœ°å€ï¼Œä»¥åŠ NAT ç©¿è¶Šå¤±è´¥åŽçš„æ•°æ®ä¸­è½¬æœåŠ¡ã€‚

é€šä¿¡è¿‡ç¨‹å¦‚ä¸‹ï¼š

- æœ¬åœ°ï¼ˆWebRTC ç»ˆç«¯ï¼‰å¯åŠ¨åŽï¼Œæ£€æµ‹è®¾å¤‡å¯ç”¨æ€§ï¼Œå¦‚æžœå¯ç”¨åŽå¼€å§‹è¿›è¡ŒéŸ³è§†é¢‘é‡‡é›†å·¥ä½œï¼›
- æœ¬åœ°å°±ç»ªåŽï¼Œå‘é€â€œåŠ å…¥æˆ¿é—´â€ä¿¡ä»¤åˆ° Signal æœåŠ¡å™¨ï¼›
- Signal æœåŠ¡å™¨åˆ›å»ºæˆ¿é—´ï¼Œç­‰å¾…åŠ å…¥ï¼›
- å¯¹ç«¯ï¼ˆWebRTC ç»ˆç«¯ï¼‰åŒæ ·æ“ä½œï¼ŒåŠ å…¥æˆ¿é—´ï¼Œå¹¶é€šçŸ¥å¦ä¸€ç«¯ï¼›
- åŒç«¯åˆ›å»ºåª’ä½“è¿žæŽ¥å¯¹è±¡ RTCPeerConnectionï¼Œè¿›è¡Œåª’ä½“åå•†ï¼›
- åŒç«¯è¿›è¡Œè¿žé€šæ€§æµ‹è¯•ï¼Œæœ€ç»ˆå»ºç«‹è¿žæŽ¥ï¼›
- å°†é‡‡é›†åˆ°çš„éŸ³è§†é¢‘æ•°æ®é€šè¿‡ RTCPeerConnection å¯¹è±¡è¿›è¡Œç¼–ç ï¼Œæœ€ç»ˆé€šè¿‡ P2P ä¼ é€ç»™å¯¹ç«¯/æœ¬åœ°ï¼Œå†è¿›è¡Œè§£ç ã€å±•ç¤ºã€‚

> ç¬¬ 6 æ­¥åœ¨å»ºç«‹è¿žæŽ¥è¿›è¡Œ P2P ç©¿è¶Šæ—¶å¾ˆæœ‰å¯èƒ½å¤±è´¥ã€‚å½“ P2P ç©¿è¶Šå¤±è´¥æ—¶ï¼Œä¸ºäº†ä¿éšœéŸ³è§†é¢‘æ•°æ®ä»ç„¶å¯ä»¥äº’é€šï¼Œåˆ™éœ€è¦é€šè¿‡ TURN æœåŠ¡å™¨è¿›è¡ŒéŸ³è§†é¢‘æ•°æ®ä¸­è½¬ã€‚åŽé¢ä¼šè®²åˆ° TURN æœåŠ¡æ˜¯ä»€ä¹ˆï¼Œä»¥åŠå¦‚ä½•æ­å»º TURN æœåŠ¡ã€‚

## éŸ³è§†é¢‘ä¸‰å¤§æž¶æž„

### mesh

Mesh æž¶æž„æ˜¯åˆ©ç”¨ Webrtc å¯¹ç­‰è¿žæŽ¥ï¼Œåœ¨å‚ä¸Žä¼šè®®çš„å„æ–¹ä¹‹é—´ä¸¤ä¸¤ P2P è¿žæŽ¥ï¼Œå³ P2P2P2Pï¼Œå½¢æˆä¸€ä¸ªç½‘çŠ¶ç»“æž„ã€‚

ä¼˜åŠ¿ ðŸ‘†

å®žçŽ°ç®€å•ï¼Œåªéœ€è¦ ICE æœåŠ¡å™¨ç”¨äºŽå®žçŽ° P2P ç©¿è¶Šå°±è¡Œï¼›

ä¸éœ€è¦æœåŠ¡å™¨ä¸­è½¬æ•°æ®ï¼ŒèŠ‚çœå¼€å‘å’Œæˆæœ¬ï¼›

å……åˆ†åˆ©ç”¨äº†å®¢æˆ·ç«¯çš„å¸¦å®½èµ„æºã€‚

ç¼ºé™· ðŸ‘‡

æ¯ç«¯éƒ½éœ€è¦å°†è‡ªå·±çš„åª’ä½“æµå‘é€åˆ°å…¶ä»–å„ç«¯ï¼Œå¹¶ä»Žå…¶ä»–å„ç«¯èŽ·å–æµï¼Œå ç”¨å¸¦å®½è¾ƒå¤šï¼Œå‚ä¸Žäººè¶Šå¤šï¼Œå ç”¨çš„å¸¦å®½å°±è¶Šå¤§ï¼Œæ‰€ä»¥å¯¹å¸¦å®½çš„è¦æ±‚æžé«˜ï¼ŒMesh æž¶æž„åœ¨çœŸå®žçš„åº”ç”¨åœºæ™¯ä¸­å‡ ä¹Žæ²¡æœ‰äººä½¿ç”¨ã€‚

### MCU

MCUï¼ˆMultipoint Conferencing Unitï¼‰æž¶æž„ç”±ä¸€ä¸ªä¸­å¿ƒåŒ–çš„ MCU æœåŠ¡å™¨ï¼ˆå¯¹åª’ä½“æµè¿›è¡Œç¼–ç ã€è½¬ç ã€è§£ç ã€æ··åˆå¤„ç†ï¼‰å’Œå¤šä¸ªç»ˆç«¯ç»„æˆä¸€ä¸ªæ˜Ÿå½¢ç»“æž„ã€‚å„ç»ˆç«¯å°†è‡ªå·±è¦å…±äº«çš„éŸ³è§†é¢‘æµå‘é€ç»™æœåŠ¡å™¨ï¼ŒæœåŠ¡ç«¯è¿›è¡Œæ··åˆåŽå†å°†å¤åˆæµå‘åˆ°å„ç«¯ã€‚

ä¼˜åŠ¿ ðŸ‘†

æ¯ä¸ªç»ˆç«¯åªéœ€å‘é€ä¸€ä»½åª’ä½“æµï¼Œå†æŽ¥æ”¶å•ä¸ªå¤åˆæµï¼Œå‡å°‘å®¢æˆ·ç«¯å¸¦å®½åŽ‹åŠ›ï¼›

æŽ¥æ”¶çš„å¤åˆæµï¼Œæ‰€æœ‰å‚ä¸Žäººçœ‹åˆ°çš„æ˜¯ç›¸åŒçš„ç”»é¢ï¼Œå®¢æˆ·ä½“éªŒéžå¸¸å¥½ã€‚

ç¼ºé™· ðŸ‘‡

éœ€è¦ä¸€å°å¼ºå¤§çš„æœºå™¨æ¥è§£ç ã€åˆæˆå’Œé‡æ–°ç¼–ç è¿™äº›å¤§é‡è¿ç®—çš„å·¥ä½œï¼Œå¯¹ CPU èµ„æºçš„æ¶ˆè€—å¾ˆå¤§ã€‚

### SFU

SFUï¼ˆSelective Forwarding Unitï¼‰æž¶æž„åŒ MCU ï¼Œä¹Ÿæ˜¯ç”±ä¸€ä¸ªä¸­å¿ƒåŒ–çš„æœåŠ¡å™¨å’Œå¤šä¸ªç»ˆç«¯ç»„æˆï¼Œä½†ä¸Ž MCU ä¸åŒçš„æ˜¯ï¼ŒSFU æœåŠ¡å™¨ä¸å¯¹éŸ³è§†é¢‘è¿›è¡Œç¼–ç ã€è§£ç ã€æ··æµç­‰ç®—åŠ›è¾ƒé«˜çš„å·¥ä½œï¼Œåªè´Ÿè´£è½¬å‘åª’ä½“æˆ–è€…å­˜å‚¨åª’ä½“ï¼Œå®žé™…ä¸Šå°±æ˜¯ä¸€ä¸ªéŸ³è§†é¢‘è·¯ç”±è½¬å‘å™¨ã€‚
SFU æ˜¯æœ€è¿‘å‡ å¹´æµè¡Œçš„æ–°æž¶æž„ï¼Œç›®å‰ WebRTC å¤šæ–¹é€šä¿¡åª’ä½“æœåŠ¡å™¨å¤§å¤šéƒ½æ˜¯ SFU æž¶æž„ã€‚

ä¼˜åŠ¿ ðŸ‘†

æœåŠ¡ç«¯åŽ‹åŠ›ç›¸å¯¹è¾ƒå°ï¼Œç”±äºŽæ˜¯æ•°æ®åŒ…ç›´æŽ¥è½¬å‘ï¼Œä¸éœ€è¦ç¼–ç ã€è§£ç ï¼Œå¯¹ CPU èµ„æºæ¶ˆè€—å¾ˆå°ï¼›

ç›´æŽ¥è½¬å‘ä¹Ÿæžå¤§åœ°é™ä½Žäº†å»¶è¿Ÿï¼Œæé«˜äº†å®žæ—¶æ€§ï¼›

å¯¹å®¢æˆ·ç«¯çš„å®½å¸¦è¦æ±‚é€‚ä¸­ï¼šé’ˆå¯¹ä½Žå»¶è¿Ÿã€é«˜å¸¦å®½åª’ä½“è½¬å‘è¿›è¡Œäº†ä¼˜åŒ–ã€‚

ç¼ºé™· ðŸ‘‡

ç”±äºŽæ˜¯æ•°æ®åŒ…ç›´æŽ¥è½¬å‘ï¼Œå‚ä¸Žäººè§‚çœ‹å¤šè·¯è§†é¢‘çš„æ—¶å€™å¯èƒ½ä¼šå‡ºçŽ°ä¸åŒæ­¥ï¼›ç›¸åŒçš„è§†é¢‘æµï¼Œä¸åŒçš„å‚ä¸Žäººçœ‹åˆ°çš„ç”»é¢ä¹Ÿå¯èƒ½ä¸ä¸€è‡´ã€‚

ç»¼åˆæ¥è¯´ï¼šSFU æ˜¯ä¸‰ç§æž¶æž„æ–¹æ¡ˆä¸­ä¼˜åŠ¿æœ€æ˜Žæ˜¾è€ŒåŠ£åŠ¿ç›¸å¯¹è¾ƒå°‘ï¼Œæ˜¯ç›®å‰æœ€ä¼˜çš„ä¸€ç§å¤šæ–¹é€šä¿¡æž¶æž„æ–¹æ¡ˆã€‚

å¼€æºå®žçŽ°

SFU æž¶æž„æœ‰ä¸€äº›æ¯”è¾ƒæµè¡Œçš„å¼€æºé¡¹ç›®ï¼Œåƒï¼š Licodeã€Janus-gatewayã€MediaSoupã€Medooze ç­‰ï¼Œæ„Ÿå…´è¶£çš„å°ä¼™ä¼´å¯ä»¥åŽ»äº†è§£ã€‚

## webrtc å®žçŽ°æ­¥éª¤

## 1.åˆ›å»ºæ•°æ®

```js
// åˆ›å»ºæ•°æ®æº
const localStream = await navigator.mediaDevices.getUserMedia({
  video: true,
  audio: true,
});
// æ˜¾ç¤ºæ•°æ®æºï¼ŒlocalVideo æ˜¯ html ä¸­çš„ video æ ‡ç­¾
localVideo.srcObject = localStream;
localVideo.onloadedmetadata = () => {
  localVideo.play();
};
```

## 2.åˆ›å»ºå‘é€æ•°æ®å®žä¾‹

ç”¨äºŽå‘é€æ­¥éª¤ä¸€ä¸­åˆ›å»ºçš„æ•°æ®ï¼š

```js
// æœ¬åœ°å®žä¾‹
const pc1 = new RTCPeerConnection();
// å¯¹ç«¯å®žä¾‹
const pc2 = new RTCPeerConnection();
```

## 3.é…ç½®å®žä¾‹

åšè¿™ä¸€æ­¥çš„ç›®çš„æ˜¯ä¸ºäº†äº¤æ¢ä¸¤ç«¯çš„ä¿¡æ¯ icecandidateÂ  å’Œ Â SDP

icecandidateï¼š åŒ…å«é€šä¿¡åè®®(TCP/UDP)å’Œé€šä¿¡ IPï¼ŒSTUN å’Œ TURN åè®®ä¸­æè¿°ç½‘ç»œä¿¡æ¯çš„æ ¼å¼è§„èŒƒï¼Œè§£å†³åŒæ–¹ç½‘ç»œé“¾æŽ¥é—®é¢˜ï¼›

SDPï¼š æµè§ˆå™¨èƒ½åŠ›ï¼ŒåŒ…æ‹¬ä¸é™äºŽéŸ³è§†é¢‘ç¼–ç æ ¼å¼ï¼Œå¸¦å®½ï¼ŒæµæŽ§ç­–ç•¥ç­‰ï¼›è§£å†³å‰ç½®æ€è€ƒä¸­ï¼ŒåŒæ–¹èƒ½åŠ›ä¸åŒ¹é…é—®é¢˜ï¼Œé€šè¿‡äº¤æ¢åŒæ–¹ SDP æµè§ˆå™¨ä¼šè‡ªåŠ¨é€‰æ‹©åŒæ–¹éƒ½æ”¯æŒçš„è§†é¢‘ç¼–ç æ ¼å¼ã€‚

```js
// å‘Šè¯‰å¯¹ç«¯ï¼Œæœ¬ç«¯åœ°å€
pc1.addEventListener("icecandidate", async (e) => {
  // å‘é€ç»™å¯¹ç«¯
  // å¯¹ç«¯æ·»åŠ æœ¬ç«¯åœ°å€
  if (e.candidate) {
    await pc2.addIceCandidate(e.candidate);
  }
});

pc2.addEventListener("icecandidate", async (e) => {
  // å‘é€ç»™æœ¬ç«¯
  // æœ¬ç«¯æ·»åŠ å¯¹ç«¯åœ°å€
  if (e.candidate) {
    await pc1.addIceCandidate(e.candidate);
  }
});

// åˆ›å»ºæœ¬ç«¯SDP,å‘Šè¯‰æœ¬ç«¯æµè§ˆå™¨æ”¯æŒå“ªäº›èƒ½åŠ›
const offer = await pc1.createOffer();
pc1.setLocalDescription(offer);
// åˆ›å»ºè¿œç«¯SDP,å‘Šè¯‰è¿œç«¯æµè§ˆå™¨æ”¯æŒå“ªäº›èƒ½åŠ›
const answer = await pc2.createAnswer();
pc2.setLocalDescription(answer);
// ã€‚ã€‚ã€‚ã€‚å‘é€è¿œç«¯SDPç»™æœ¬ç«¯
// æŽ¥æ”¶è¿œç«¯sdp,å‘Šè¯‰è¿œç«¯æµè§ˆå™¨æ”¯æŒå“ªäº›èƒ½åŠ›
pc1.setRemoteDescription(answer);
// æŽ¥æ”¶å®¢æˆ·ç«¯sdp,å‘Šè¯‰è¿œç«¯æµè§ˆå™¨æ”¯æŒå“ªäº›èƒ½åŠ›
pc2.setRemoteDescription(offer);
```

## 4. å‘é€æ•°æ®

```js
localStream.getTracks().forEach((track) => pc1.addTrack(track, localStream));
```

## 5.æŽ¥æ”¶æ•°æ®

```js
// æŽ¥æ”¶è¿œç«¯æ•°æ®
pc2.addEventListener("track", (e) => {
  remoteVideo.srcObject = e.streams[0];
});
```

## 6.å…³é—­è¿žæŽ¥

```js
// å…³é—­è¿žæŽ¥
pc1.close();
pc2.close();
```

## å®Œæ•´ä»£ç 

```ts
const pc1 = new RTCPeerConnection();
pc1.addEventListener("icecandidate", async (e) => {
  if (e.candidate) {
    await pc2.addIceCandidate(e.candidate);
  }
});
pc1.addEventListener("iceconnectionstatechange", (e) => {
  console.log("pc1: iceconnectionstatechange", e);
});

const pc2 = new RTCPeerConnection();
pc2.addEventListener("icecandidate", async (e) => {
  if (e.candidate) {
    await pc1.addIceCandidate(e.candidate);
  }
});

pc2.addEventListener("iceconnectionstatechange", (e) => {
  console.log("pc2: iceconnectionstatechange", e);
});

pc2.addEventListener("track", (e) => {
  if (e.streams.length > 0) {
    remoteVideo.srcObject = e.streams[0];
  }
});

const remoteVideo = document.querySelector("#remoteVideo") as HTMLVideoElement;
const localVideo = document.querySelector("#localVideo") as HTMLVideoElement;

async function pushStream(answer: RTCSessionDescriptionInit) {
  pc1.setRemoteDescription(answer);
}

async function pullStream(offer: RTCSessionDescriptionInit): Promise<void> {
  pc2.setRemoteDescription(offer);
  const answer = await pc2.createAnswer();
  pc2.setLocalDescription(answer);
  console.warn("answer", answer);
  pushStream(answer);
}

window.onload = async () => {
  const localStream = await navigator.mediaDevices.getUserMedia({
    video: true,
    audio: true,
  });

  localVideo.srcObject = localStream;
  localStream.getTracks().forEach((track) => pc1.addTrack(track, localStream));

  const offer = await pc1.createOffer();
  pc1.setLocalDescription(offer);
  console.warn("pc1 offer", offer);
  pullStream(offer);
};
```
